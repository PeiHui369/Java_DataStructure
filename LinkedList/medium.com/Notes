@ General
class Node {}
class Main {
  i. printList
  ii. Special code function
  iii. Main {
              int[] keys = {1,2,3,4,5};  //input keys
              Node head = null;          //point to the head node of the linked list
              for (int i = keys.length-1; i>=0; i--) {head = newNode(keys[i], head);} //Construct a linked list
              /*Special code function*/
              printList(head)             //print linked list
        }
              
@ Node class
class Node
{
    int data;
    Node next;
 
    Node(int data, Node next)
    {
        this.data = data;
        this.next = next;
    }
}

@ Print
public static void printList(Node head)
    {
        for (Node ptr = head; ptr != null; ptr = ptr.next) {
            System.out.print(ptr.data + " â€”> ");
        }
        System.out.println("null");
    }

@ insert a node at beginning
void push(int data){
  Node newNode = new Node(data);
  newNode.next = head;
  head = newNode;
}


03 Insertion at tail
public static Node push(int data, Node head)
    {
        Node newNode = new Node();
        newNode.data = data;
        newNode.next = head;
        return newNode;
    }
 
    public static Node appendNode(Node head, int key)
    {
        Node current = head;
 
        if (head == null) {
            head = push(key, null);
        }
        else {
            while (current.next != null) {
                current = current.next;
            }
            current.next = push(key, null);
        }
 
        return head;
    }

04 Static Linked List
i. Using iterator
 public static void main(String[] args)
    {
        int[] arr = { 1, 2, 3, 4, 5 };
 
        Node[] node = new Node[arr.length];
        for (int i = 0; i < arr.length; i++)
        {
            node[i] = new Node(arr[i], null);
 
            if (i > 0) {
                node[i - 1].next = node[i];
            }
        }
 
        Node head = node[0];
        printList(head);
    }

ii. Placing code inside block scope & accessing nodes outside block scope
public static void main(String[] args)
    {
        int arr[] = { 1, 2, 3, 4, 5 };
 
        Node head = null;
 
        // Entering block scope
        {
            Node[] node = new Node[arr.length];
            for (int i = 0; i < arr.length; i++)
            {
                node[i] = new Node(arr[i], null);
 
                if (i > 0) {
                    node[i - 1].next = node[i];
                }
            }
 
            head = node[0];
        }
        // Exiting block scope
 
        printList(head);
    }

iii. Make storage global
    public static final int N =5;
    private static Node[] node = new Node[N];
    
    public static Node createStaticList(int arr[]){
        for(int i = 0; i <arr.length; i++){
            node[i] = new Node(arr[i], null);
            if(i>0) {
                node[i-1].next = node[i];
            }
        }
        return node[0];
    }
    
    public static void main(String[] args){
        int arr[] = {1,2,3,4,5};
        Node head = createStaticList(arr);
        printList(head);
    }

05 Clone a linked list
i. Naive
//Function takes a linked list and returns its complete copy
    public static Node copyList(Node head) {
        Node current = head;    //used to iterate over the original list
        Node newList = null;    //head of the new list
        Node tail = null;       //point to the last node in a new list

        while (current != null){
            //special case for the first new node
            if(newList == null){
                newList = new Node(current.data, null);
                tail = newList;
            }else{
                tail.next = new Node();
                tail = tail.next;
                tail.data = current.data;
                tail.next = null;
            }
            current = current.next;
        }
        return newList;
    }

    public static void main(String[] args){
        //input keys
        int[] keys = {1,2,3,4};
        //points to the head node of the linked list
        Node haad = null;
        //construct a linked list
        for(int i = keys.length-1; i>=0; i--){
            head = new Node(keys[i], head);
        }
        //copy linked list
        Node copy = copyList(head);
        //print duplicate linked list
        printList(copy);
    }

ii. Using push()
 while (current != null){
            //special case for the first new node
            if(newList == null){
                newList = new Node(current.data, newList);
                tail = newList;
            }else{
                tail.next = new Node(current.data, tail.next);
                tail = tail.next;
            }

iii. Using Dummy Node to take care of first node case
The dumy node is temporarily the first node in the list, and the tail pointer starts off pointing to it
All the nodes are added off the tail pointer
public static Node copyList(Node head) {
        Node current = head;    //used to iterate over the original list
        Node tail;              //point to the last node in the new list
        Node dummy = new Node();//build the new list of this dummy node
        tail = dummy;           //start the tail pointing at the dummy

        while (current != null) {
            //add each node at the tail
            tail.next = new Node(current.data, tail.next);
            //advance the tail to the new last node
            tail = tail.next;
            current = current.next;
        }
        return dummy.next;
    }

iv. Recursive
public static Node copyList(Node head){
        if (head == null) {
            return null;
        }
        //Allocate a new node in a heap and set its data
        Node newNode = new Node (head.data);
        //Recursively set the next field of the new node by recurring for the rest nodes
        newNode.next = copyList(head.next);
        return newNode;
    }

06 Delete a LinkedList (Recursive)
// Recursive function to delete a linked list
    void deleteList() {
        deleteListRecursive(head);
        head = null;
    }

    // Helper function to delete the linked list recursively
    void deleteListRecursive(Node node) {
        if (node == null) {
            return;
        }

        deleteListRecursive(node.next);

        System.out.println("Deleting " + node.data);
        node.next = null;
    }

07 Pop Operation
    //The opposite of 'push()'
    //Takes a non-empty list, removes the front node, and prints the data in that node
    public static Node pop(Node headRef){
        //underflow condition
        if(headRef == null) {
            return null;
        }
        int result = headRef.data;  //pull out data before the node is deleted;
        headRef = headRef.next;     //unlink the head node for the caller
        System.out.println("The popped node is " + result);
        return headRef;
    }

08 Insert a node to its correct sorted position in a sorted linked list
    //Function to insert a given node  at its correct sorted position into a given list sorted in increasing order
    public static Node sortedInsert(Node head, Node newNode){
        //special case for the head end
        if (head == null || head.data >= newNode.data)
        {
            newNode.next = head;
            head = newNode;
            return head;
        }
        //locate the node before the point of insertion
        Node current = head;
        while(current.next != null && current.next.data < newNode.data){
            current = current.next;
        }
        newNode.next = current.next;
        current.next = newNode;
        return head;
    }

09 Sort LinkedList
//Insert a given node at its correct sorted position into a given list sorted in increasing order
    public static Node sortedInsert(Node head, Node newNode){
        Node dummy = new Node();
        Node current = dummy;
        dummy.next = head;
        
        while (current.next != null && current.next.data < newNode.data) {
            current = current.next;
        }
        
        newNode.next = current.next;
        current.next = newNode;
        return dummy.next;
    }
    
    //Given a list, change it to be in sorted order (using 'sortedInsert()')
    public static Node insertSort(Node head){
        Node result = null;     //build the answer here
        Node current = head;    //iterate over the original list
        Node next;
        
        while (current != null){
            //tricky: note the next reference before we change it
            next = current.next;
            result = sortedInsert(result, current);
            current = next;
        }
        
        return result;
    }
    //Main: head = insertSort(head) -> printList(head)

10 Split nodes into front & back halves
//Return the total number of nodes in a list
    public static int findLength(Node head) {
        int count = 0;
        Node ptr = head;
        while (ptr != null){
            count++;
            ptr = ptr.next;
        }
        return count;
    }

    //Split the given list's nodes into front and back halve,
    // and return the two lists using an array.
    // If the length is odd, the extra node should go in the front list
    public static Node[] frontBackSplit(Node source) {
        Node frontRef, backRef;
        int len = findLength(source);
        if (len<2){
            frontRef = source;
            backRef = null;
            return new Node[] {frontRef, backRef};
        }
        Node current = source;
        int hopCount = (len-1)/2;
        for (int i = 0; i<hopCount; i++){
            current = current.next;
        }
        //Now cut at current
        frontRef = source;
        backRef = current.next;
        current.next = null;

        return new Node[] {frontRef, backRef};
    }
    
    /*
        Node[] nodes = frontBackSplit(head);
 
        // print linked list
        printList("Front List: ", nodes[0]);
        printList("Back List: ", nodes[1]);
     */
#2. Fast/Slow Pointer Strategy

11 Remove Duplicates
